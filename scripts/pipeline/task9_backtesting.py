"""
Task 9: Backtesting Framework
NBA Player Props Betting System

This script analyzes historical predictions vs actual outcomes to:
1. Calculate actual ROI and win rates
2. Break down performance by prop type, edge size, player tier
3. Identify optimal betting strategies
4. Validate model effectiveness

Uses the predictions_*.csv files generated by Task 6.
"""

import pandas as pd
import numpy as np
import argparse
from pathlib import Path
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

# Try to import matplotlib for visualizations
try:
    import matplotlib.pyplot as plt
    HAS_MATPLOTLIB = True
except ImportError:
    HAS_MATPLOTLIB = False


# =============================================================================
# CONFIGURATION
# =============================================================================

PROPS = ['pts', 'trb', 'ast', 'stl', 'blk', 'tov', 'pra', 'pr', 'pa']

PROP_DISPLAY_NAMES = {
    'pts': 'Points',
    'trb': 'Rebounds', 
    'ast': 'Assists',
    'stl': 'Steals',
    'blk': 'Blocks',
    'tov': 'Turnovers',
    'pra': 'Pts+Reb+Ast',
    'pr': 'Pts+Reb',
    'pa': 'Pts+Ast'
}

# Standard juice/vig
STANDARD_ODDS = -110
BREAKEVEN_PCT = 0.5238  # 52.38% needed to break even at -110


# =============================================================================
# DATA LOADING
# =============================================================================

def load_predictions(pred_dir: Path = Path('.')) -> pd.DataFrame:
    """
    Load all prediction files and combine into single DataFrame.
    
    Expected files: predictions_pts.csv, predictions_trb.csv, etc.
    """
    all_preds = []
    
    for prop in PROPS:
        filepath = pred_dir / f'predictions_{prop}.csv'
        if filepath.exists():
            df = pd.read_csv(filepath)
            df['prop'] = prop
            df['game_date'] = pd.to_datetime(df['game_date'])
            all_preds.append(df)
            print(f"  ✓ Loaded {prop}: {len(df):,} predictions")
        else:
            print(f"  ⚠ Missing: predictions_{prop}.csv")
    
    if not all_preds:
        return None
    
    combined = pd.concat(all_preds, ignore_index=True)
    print(f"\nTotal: {len(combined):,} predictions across {len(all_preds)} props")
    
    return combined


def load_player_data(data_path: str = 'player_games_schedule.csv') -> pd.DataFrame:
    """Load player data for additional context (minutes, etc.)"""
    if Path(data_path).exists():
        df = pd.read_csv(data_path, parse_dates=['game_date'])
        return df
    return None


# =============================================================================
# BET SIMULATION
# =============================================================================

def simulate_bet(prediction: float, actual: float, line: float, 
                 odds: int = STANDARD_ODDS) -> dict:
    """
    Simulate a single bet.
    
    Args:
        prediction: Model's prediction
        actual: Actual outcome
        line: Betting line
        odds: American odds (default -110)
    
    Returns:
        Dictionary with bet details and outcome
    """
    # Determine bet direction based on prediction vs line
    if prediction > line:
        direction = 'OVER'
        won = actual > line
    else:
        direction = 'UNDER'
        won = actual < line
    
    # Edge (how far prediction is from line)
    edge = abs(prediction - line)
    
    # Calculate profit/loss
    if won:
        if odds > 0:
            profit = odds / 100  # e.g., +150 = 1.5 units profit
        else:
            profit = 100 / abs(odds)  # e.g., -110 = 0.909 units profit
    else:
        profit = -1.0  # Lost 1 unit
    
    return {
        'direction': direction,
        'edge': edge,
        'won': won,
        'profit': profit,
        'prediction': prediction,
        'actual': actual,
        'line': line
    }


def run_backtest(df: pd.DataFrame, min_edge: float = 0, 
                 odds: int = STANDARD_ODDS) -> pd.DataFrame:
    """
    Run backtest on all predictions.
    
    Args:
        df: DataFrame with predictions
        min_edge: Minimum edge to place bet (default 0 = bet everything)
        odds: American odds for all bets
    
    Returns:
        DataFrame with bet results
    """
    results = []
    
    for _, row in df.iterrows():
        # Skip if missing data
        if pd.isna(row['predicted']) or pd.isna(row['actual']) or pd.isna(row['line']):
            continue
        
        bet = simulate_bet(
            prediction=row['predicted'],
            actual=row['actual'],
            line=row['line'],
            odds=odds
        )
        
        # Only include if edge meets threshold
        if bet['edge'] >= min_edge:
            bet['player'] = row['player']
            bet['game_date'] = row['game_date']
            bet['prop'] = row['prop']
            results.append(bet)
    
    return pd.DataFrame(results)


# =============================================================================
# PERFORMANCE METRICS
# =============================================================================

def calculate_metrics(results: pd.DataFrame) -> dict:
    """Calculate comprehensive betting metrics."""
    if len(results) == 0:
        return {
            'total_bets': 0,
            'wins': 0,
            'losses': 0,
            'win_rate': 0,
            'total_profit': 0,
            'roi': 0,
            'avg_edge': 0
        }
    
    wins = results['won'].sum()
    losses = len(results) - wins
    win_rate = wins / len(results)
    total_profit = results['profit'].sum()
    roi = (total_profit / len(results)) * 100  # ROI per unit bet
    avg_edge = results['edge'].mean()
    
    return {
        'total_bets': len(results),
        'wins': int(wins),
        'losses': int(losses),
        'win_rate': win_rate,
        'win_rate_pct': win_rate * 100,
        'total_profit': total_profit,
        'roi': roi,
        'avg_edge': avg_edge,
        'profitable': win_rate > BREAKEVEN_PCT
    }


def analyze_by_prop(results: pd.DataFrame) -> pd.DataFrame:
    """Break down performance by prop type."""
    prop_stats = []
    
    for prop in results['prop'].unique():
        prop_df = results[results['prop'] == prop]
        metrics = calculate_metrics(prop_df)
        metrics['prop'] = prop
        metrics['prop_name'] = PROP_DISPLAY_NAMES.get(prop, prop)
        prop_stats.append(metrics)
    
    return pd.DataFrame(prop_stats).sort_values('roi', ascending=False)


def analyze_by_edge_bucket(results: pd.DataFrame) -> pd.DataFrame:
    """Break down performance by edge size."""
    # Create edge buckets
    bins = [0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 5.0, 100]
    labels = ['0-0.5', '0.5-1', '1-1.5', '1.5-2', '2-2.5', '2.5-3', '3-5', '5+']
    
    results = results.copy()
    results['edge_bucket'] = pd.cut(results['edge'], bins=bins, labels=labels)
    
    bucket_stats = []
    for bucket in labels:
        bucket_df = results[results['edge_bucket'] == bucket]
        if len(bucket_df) > 0:
            metrics = calculate_metrics(bucket_df)
            metrics['edge_bucket'] = bucket
            bucket_stats.append(metrics)
    
    return pd.DataFrame(bucket_stats)


def analyze_by_direction(results: pd.DataFrame) -> pd.DataFrame:
    """Break down performance by bet direction (over/under)."""
    direction_stats = []
    
    for direction in ['OVER', 'UNDER']:
        dir_df = results[results['direction'] == direction]
        if len(dir_df) > 0:
            metrics = calculate_metrics(dir_df)
            metrics['direction'] = direction
            direction_stats.append(metrics)
    
    return pd.DataFrame(direction_stats)


def analyze_by_date(results: pd.DataFrame) -> pd.DataFrame:
    """Track cumulative performance over time."""
    results = results.sort_values('game_date')
    results['cumulative_profit'] = results['profit'].cumsum()
    results['cumulative_bets'] = range(1, len(results) + 1)
    results['cumulative_roi'] = (results['cumulative_profit'] / results['cumulative_bets']) * 100
    
    # Daily aggregation
    daily = results.groupby('game_date').agg({
        'profit': 'sum',
        'won': ['sum', 'count']
    }).reset_index()
    daily.columns = ['game_date', 'daily_profit', 'daily_wins', 'daily_bets']
    daily['daily_win_rate'] = daily['daily_wins'] / daily['daily_bets']
    daily['cumulative_profit'] = daily['daily_profit'].cumsum()
    
    return daily


def analyze_by_player_tier(results: pd.DataFrame, player_data: pd.DataFrame = None) -> pd.DataFrame:
    """Break down performance by player minutes tier."""
    if player_data is None:
        return None
    
    # Get average minutes for each player
    player_mins = player_data.groupby('player')['mp_l10'].mean().reset_index()
    player_mins.columns = ['player', 'avg_minutes']
    
    # Merge with results
    results = results.merge(player_mins, on='player', how='left')
    
    # Create tiers
    bins = [0, 15, 25, 32, 100]
    labels = ['Bench (<15)', 'Rotation (15-25)', 'Starter (25-32)', 'Star (32+)']
    results['player_tier'] = pd.cut(results['avg_minutes'], bins=bins, labels=labels)
    
    tier_stats = []
    for tier in labels:
        tier_df = results[results['player_tier'] == tier]
        if len(tier_df) > 0:
            metrics = calculate_metrics(tier_df)
            metrics['player_tier'] = tier
            tier_stats.append(metrics)
    
    return pd.DataFrame(tier_stats)


# =============================================================================
# OPTIMAL STRATEGY FINDER
# =============================================================================

def find_optimal_edge_threshold(results: pd.DataFrame) -> dict:
    """Find the edge threshold that maximizes ROI."""
    thresholds = np.arange(0, 5.1, 0.25)
    best = {'threshold': 0, 'roi': -100, 'metrics': None}
    
    threshold_results = []
    
    for thresh in thresholds:
        filtered = results[results['edge'] >= thresh]
        if len(filtered) >= 50:  # Minimum sample size
            metrics = calculate_metrics(filtered)
            threshold_results.append({
                'threshold': thresh,
                'bets': metrics['total_bets'],
                'win_rate': metrics['win_rate_pct'],
                'roi': metrics['roi'],
                'profit': metrics['total_profit']
            })
            
            if metrics['roi'] > best['roi']:
                best = {
                    'threshold': thresh,
                    'roi': metrics['roi'],
                    'metrics': metrics
                }
    
    return best, pd.DataFrame(threshold_results)


def find_best_props(results: pd.DataFrame, min_bets: int = 100) -> list:
    """Identify props with best ROI."""
    prop_analysis = analyze_by_prop(results)
    profitable = prop_analysis[
        (prop_analysis['total_bets'] >= min_bets) & 
        (prop_analysis['roi'] > 0)
    ]
    return profitable.sort_values('roi', ascending=False)


# =============================================================================
# REPORTING
# =============================================================================

def print_summary(metrics: dict, title: str = "OVERALL PERFORMANCE"):
    """Print formatted performance summary."""
    print(f"\n{'='*60}")
    print(f"{title}")
    print(f"{'='*60}")
    
    print(f"\n  Total Bets:     {metrics['total_bets']:,}")
    print(f"  Record:         {metrics['wins']}-{metrics['losses']}")
    print(f"  Win Rate:       {metrics['win_rate_pct']:.1f}%", end='')
    
    if metrics['win_rate'] > BREAKEVEN_PCT:
        print(f" ✓ (>{BREAKEVEN_PCT*100:.1f}% needed)")
    else:
        print(f" ✗ (<{BREAKEVEN_PCT*100:.1f}% needed)")
    
    print(f"\n  Total Profit:   {metrics['total_profit']:+.2f} units")
    print(f"  ROI:            {metrics['roi']:+.2f}%")
    print(f"  Avg Edge:       {metrics['avg_edge']:.2f} pts")
    
    status = "PROFITABLE ✓" if metrics.get('profitable', False) else "NOT PROFITABLE ✗"
    print(f"\n  Status:         {status}")


def print_prop_breakdown(prop_df: pd.DataFrame):
    """Print performance by prop type."""
    print(f"\n{'='*60}")
    print("PERFORMANCE BY PROP TYPE")
    print(f"{'='*60}")
    
    print(f"\n  {'Prop':<15} {'Bets':>7} {'Win%':>7} {'ROI':>8} {'Profit':>10}")
    print(f"  {'─'*50}")
    
    for _, row in prop_df.iterrows():
        status = "✓" if row['roi'] > 0 else "✗"
        print(f"  {row['prop_name']:<15} {row['total_bets']:>7,} "
              f"{row['win_rate_pct']:>6.1f}% {row['roi']:>+7.1f}% "
              f"{row['total_profit']:>+9.1f} {status}")


def print_edge_breakdown(edge_df: pd.DataFrame):
    """Print performance by edge bucket."""
    print(f"\n{'='*60}")
    print("PERFORMANCE BY EDGE SIZE")
    print(f"{'='*60}")
    
    print(f"\n  {'Edge':<10} {'Bets':>7} {'Win%':>7} {'ROI':>8} {'Profit':>10}")
    print(f"  {'─'*45}")
    
    for _, row in edge_df.iterrows():
        status = "✓" if row['roi'] > 0 else "✗"
        print(f"  {row['edge_bucket']:<10} {row['total_bets']:>7,} "
              f"{row['win_rate_pct']:>6.1f}% {row['roi']:>+7.1f}% "
              f"{row['total_profit']:>+9.1f} {status}")


def print_direction_breakdown(dir_df: pd.DataFrame):
    """Print performance by direction."""
    print(f"\n{'='*60}")
    print("PERFORMANCE BY DIRECTION")
    print(f"{'='*60}")
    
    print(f"\n  {'Direction':<10} {'Bets':>7} {'Win%':>7} {'ROI':>8} {'Profit':>10}")
    print(f"  {'─'*45}")
    
    for _, row in dir_df.iterrows():
        status = "✓" if row['roi'] > 0 else "✗"
        print(f"  {row['direction']:<10} {row['total_bets']:>7,} "
              f"{row['win_rate_pct']:>6.1f}% {row['roi']:>+7.1f}% "
              f"{row['total_profit']:>+9.1f} {status}")


def print_tier_breakdown(tier_df: pd.DataFrame):
    """Print performance by player tier."""
    if tier_df is None or len(tier_df) == 0:
        return
    
    print(f"\n{'='*60}")
    print("PERFORMANCE BY PLAYER TIER")
    print(f"{'='*60}")
    
    print(f"\n  {'Tier':<20} {'Bets':>7} {'Win%':>7} {'ROI':>8} {'Profit':>10}")
    print(f"  {'─'*55}")
    
    for _, row in tier_df.iterrows():
        status = "✓" if row['roi'] > 0 else "✗"
        print(f"  {row['player_tier']:<20} {row['total_bets']:>7,} "
              f"{row['win_rate_pct']:>6.1f}% {row['roi']:>+7.1f}% "
              f"{row['total_profit']:>+9.1f} {status}")


def print_optimal_strategy(best: dict, threshold_df: pd.DataFrame):
    """Print optimal strategy findings."""
    print(f"\n{'='*60}")
    print("OPTIMAL BETTING STRATEGY")
    print(f"{'='*60}")
    
    print(f"\n  Best Edge Threshold: {best['threshold']:.2f} pts")
    if best['metrics']:
        print(f"  At this threshold:")
        print(f"    - Bets: {best['metrics']['total_bets']:,}")
        print(f"    - Win Rate: {best['metrics']['win_rate_pct']:.1f}%")
        print(f"    - ROI: {best['metrics']['roi']:+.2f}%")
        print(f"    - Profit: {best['metrics']['total_profit']:+.1f} units")
    
    # Show threshold progression
    print(f"\n  {'Threshold':<12} {'Bets':>7} {'Win%':>7} {'ROI':>8}")
    print(f"  {'─'*40}")
    for _, row in threshold_df.head(10).iterrows():
        print(f"  {row['threshold']:<12.2f} {row['bets']:>7,} "
              f"{row['win_rate']:>6.1f}% {row['roi']:>+7.1f}%")


def print_recommendations(results: pd.DataFrame, prop_df: pd.DataFrame, 
                          best: dict, edge_df: pd.DataFrame):
    """Print actionable recommendations."""
    print(f"\n{'='*60}")
    print("RECOMMENDATIONS")
    print(f"{'='*60}")
    
    recommendations = []
    
    # Check overall profitability
    overall = calculate_metrics(results)
    if overall['profitable']:
        recommendations.append("✓ Model is profitable overall - continue using")
    else:
        recommendations.append("⚠ Model not profitable overall - apply filters")
    
    # Best props
    profitable_props = prop_df[prop_df['roi'] > 0]['prop'].tolist()
    if profitable_props:
        prop_names = [PROP_DISPLAY_NAMES.get(p, p) for p in profitable_props]
        recommendations.append(f"✓ Focus on: {', '.join(prop_names)}")
    
    # Avoid unprofitable props
    unprofitable_props = prop_df[prop_df['roi'] < -5]['prop'].tolist()
    if unprofitable_props:
        prop_names = [PROP_DISPLAY_NAMES.get(p, p) for p in unprofitable_props]
        recommendations.append(f"✗ Avoid: {', '.join(prop_names)}")
    
    # Edge threshold
    if best['threshold'] > 0:
        recommendations.append(f"✓ Use minimum edge of {best['threshold']:.1f} pts")
    
    # Edge bucket insights
    high_edge = edge_df[edge_df['edge_bucket'].isin(['2-2.5', '2.5-3', '3-5', '5+'])]
    if len(high_edge) > 0 and high_edge['roi'].mean() > 5:
        recommendations.append("✓ Higher edges (2+ pts) significantly more profitable")
    
    print()
    for i, rec in enumerate(recommendations, 1):
        print(f"  {i}. {rec}")


# =============================================================================
# VISUALIZATION
# =============================================================================

def plot_cumulative_profit(daily_df: pd.DataFrame, output_path: str = None):
    """Plot cumulative profit over time."""
    if not HAS_MATPLOTLIB:
        print("  ⚠ matplotlib not installed, skipping plots")
        return
    
    fig, axes = plt.subplots(2, 1, figsize=(12, 8))
    
    # Cumulative profit
    ax1 = axes[0]
    ax1.plot(daily_df['game_date'], daily_df['cumulative_profit'], 
             color='blue', linewidth=2)
    ax1.axhline(y=0, color='red', linestyle='--', alpha=0.5)
    ax1.fill_between(daily_df['game_date'], 0, daily_df['cumulative_profit'],
                     where=daily_df['cumulative_profit'] > 0, alpha=0.3, color='green')
    ax1.fill_between(daily_df['game_date'], 0, daily_df['cumulative_profit'],
                     where=daily_df['cumulative_profit'] < 0, alpha=0.3, color='red')
    ax1.set_title('Cumulative Profit Over Time', fontsize=14)
    ax1.set_ylabel('Profit (units)')
    ax1.grid(True, alpha=0.3)
    
    # Daily win rate
    ax2 = axes[1]
    ax2.bar(daily_df['game_date'], daily_df['daily_win_rate'] * 100, 
            color='steelblue', alpha=0.7)
    ax2.axhline(y=BREAKEVEN_PCT * 100, color='red', linestyle='--', 
                label=f'Breakeven ({BREAKEVEN_PCT*100:.1f}%)')
    ax2.set_title('Daily Win Rate', fontsize=14)
    ax2.set_ylabel('Win Rate (%)')
    ax2.set_ylim(0, 100)
    ax2.legend()
    ax2.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    if output_path:
        plt.savefig(output_path, dpi=150, bbox_inches='tight')
        print(f"  ✓ Saved plot: {output_path}")
    else:
        plt.show()


def plot_roi_by_edge(threshold_df: pd.DataFrame, output_path: str = None):
    """Plot ROI vs edge threshold."""
    if not HAS_MATPLOTLIB:
        return
    
    fig, ax = plt.subplots(figsize=(10, 6))
    
    ax.plot(threshold_df['threshold'], threshold_df['roi'], 
            marker='o', linewidth=2, markersize=6)
    ax.axhline(y=0, color='red', linestyle='--', alpha=0.5)
    ax.fill_between(threshold_df['threshold'], 0, threshold_df['roi'],
                    where=threshold_df['roi'] > 0, alpha=0.3, color='green')
    
    # Mark optimal point
    best_idx = threshold_df['roi'].idxmax()
    best_row = threshold_df.loc[best_idx]
    ax.scatter([best_row['threshold']], [best_row['roi']], 
               color='gold', s=200, zorder=5, edgecolor='black')
    ax.annotate(f"Optimal: {best_row['threshold']:.1f} pts\nROI: {best_row['roi']:.1f}%",
                xy=(best_row['threshold'], best_row['roi']),
                xytext=(best_row['threshold'] + 0.5, best_row['roi'] + 2),
                fontsize=10, ha='left')
    
    ax.set_xlabel('Minimum Edge Threshold (pts)', fontsize=12)
    ax.set_ylabel('ROI (%)', fontsize=12)
    ax.set_title('ROI vs Edge Threshold', fontsize=14)
    ax.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    if output_path:
        plt.savefig(output_path, dpi=150, bbox_inches='tight')
        print(f"  ✓ Saved plot: {output_path}")
    else:
        plt.show()


# =============================================================================
# EXPORT
# =============================================================================

def export_results(results: pd.DataFrame, output_path: str):
    """Export detailed results to CSV."""
    results.to_csv(output_path, index=False)
    print(f"\n✓ Exported {len(results):,} bet results to: {output_path}")


def export_summary(prop_df: pd.DataFrame, edge_df: pd.DataFrame, 
                   best: dict, output_path: str):
    """Export summary statistics to CSV."""
    with open(output_path, 'w') as f:
        f.write("NBA Props Backtesting Summary\n")
        f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n\n")
        
        f.write("=== BY PROP TYPE ===\n")
        prop_df.to_csv(f, index=False)
        f.write("\n")
        
        f.write("=== BY EDGE SIZE ===\n")
        edge_df.to_csv(f, index=False)
        f.write("\n")
        
        f.write("=== OPTIMAL STRATEGY ===\n")
        f.write(f"Best Edge Threshold: {best['threshold']}\n")
        if best['metrics']:
            f.write(f"ROI at Optimal: {best['metrics']['roi']:.2f}%\n")
    
    print(f"✓ Exported summary to: {output_path}")


# =============================================================================
# MAIN
# =============================================================================

def main():
    parser = argparse.ArgumentParser(
        description='Backtest NBA player props predictions',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python task9_backtesting.py
  python task9_backtesting.py --min-edge 1.5
  python task9_backtesting.py --output backtest_results.csv --plot
  python task9_backtesting.py --props pts,trb,ast
        """
    )
    
    parser.add_argument('--pred-dir', default='.', help='Directory with predictions_*.csv files')
    parser.add_argument('--data', default='player_games_schedule.csv', help='Player data file')
    parser.add_argument('--min-edge', type=float, default=0, help='Minimum edge to include')
    parser.add_argument('--props', help='Props to analyze (comma separated)')
    parser.add_argument('--output', '-o', help='Export detailed results to CSV')
    parser.add_argument('--summary', help='Export summary to file')
    parser.add_argument('--plot', action='store_true', help='Generate plots')
    parser.add_argument('--plot-dir', default='.', help='Directory for plot output')
    
    args = parser.parse_args()
    
    print("="*60)
    print("Task 9: Backtesting Framework")
    print("="*60)
    
    # Load predictions
    print("\nLoading predictions...")
    predictions = load_predictions(Path(args.pred_dir))
    
    if predictions is None or len(predictions) == 0:
        print("\n✗ No predictions found. Run task6_train_models.py first.")
        return
    
    # Filter by props if specified
    if args.props:
        props_list = [p.strip().lower() for p in args.props.split(',')]
        predictions = predictions[predictions['prop'].isin(props_list)]
        print(f"\nFiltered to props: {props_list}")
    
    # Load player data for tier analysis
    player_data = load_player_data(args.data)
    
    # Run backtest
    print(f"\nRunning backtest (min edge: {args.min_edge})...")
    results = run_backtest(predictions, min_edge=args.min_edge)
    
    if len(results) == 0:
        print("\n✗ No bets meet the criteria.")
        return
    
    # Calculate metrics
    overall_metrics = calculate_metrics(results)
    prop_breakdown = analyze_by_prop(results)
    edge_breakdown = analyze_by_edge_bucket(results)
    direction_breakdown = analyze_by_direction(results)
    daily_breakdown = analyze_by_date(results)
    tier_breakdown = analyze_by_player_tier(results, player_data)
    
    # Find optimal strategy
    best_threshold, threshold_df = find_optimal_edge_threshold(results)
    
    # Print reports
    print_summary(overall_metrics)
    print_prop_breakdown(prop_breakdown)
    print_edge_breakdown(edge_breakdown)
    print_direction_breakdown(direction_breakdown)
    print_tier_breakdown(tier_breakdown)
    print_optimal_strategy(best_threshold, threshold_df)
    print_recommendations(results, prop_breakdown, best_threshold, edge_breakdown)
    
    # Generate plots
    if args.plot:
        print(f"\n{'='*60}")
        print("GENERATING PLOTS")
        print(f"{'='*60}")
        
        plot_dir = Path(args.plot_dir)
        plot_cumulative_profit(daily_breakdown, 
                              str(plot_dir / 'backtest_cumulative_profit.png'))
        plot_roi_by_edge(threshold_df,
                        str(plot_dir / 'backtest_roi_by_edge.png'))
    
    # Export results
    if args.output:
        export_results(results, args.output)
    
    if args.summary:
        export_summary(prop_breakdown, edge_breakdown, best_threshold, args.summary)
    
    print("\n" + "="*60)
    print("BACKTEST COMPLETE")
    print("="*60)


if __name__ == "__main__":
    main()
